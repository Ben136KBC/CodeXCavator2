// Copyright 2014 Christoph Brzozowski
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using CodeXCavator.Engine.Interfaces;

namespace CodeXCavator.Engine.Enumerators
{
    /// <summary>
    /// CompoundFileEnumerator class.
    /// 
    /// The CompoundFileEnumerator class allows to combine mutliple file enumerators into one.
    /// It also assures that equal files are only enumerated once, i.e. the resulting file list
    /// contains only unique elements.
    /// 
    /// Additionally it allows to associate each enumerator with a filter chain.
    /// </summary>
    public class CompoundFileEnumerator : IFileEnumerator
    {
        /// <summary>
        /// Default constructor.
        /// </summary>
        public CompoundFileEnumerator() : this( null )
        {
        }

        /// <summary>
        /// Configuration constructor.
        /// 
        /// This constructor allows to specify the file enumerators which should be merged into a single file enumerator.
        /// Each file enumerator may be associated with a filter chain, i.e. all files generated by the file enumerator
        /// are passed through the filter chain before they are merged into a single file list.
        /// </summary>
        /// <param name="fileEnumerators">List of file enumerator and filter chain pairs. The filter chain may be null.</param>
        public CompoundFileEnumerator( params KeyValuePair<IFileEnumerator, IFilterChain>[] fileEnumerators ) : this( (IEnumerable< KeyValuePair<IFileEnumerator, IFilterChain> > ) fileEnumerators )
        {
        }

        /// <summary>
        /// Configuration constructor.
        /// 
        /// This constructor allows to specify the file enumerators which should be merged into a single file enumerator.
        /// Each file enumerator may be associated with a filter chain, i.e. all files generated by the file enumerator
        /// are passed through the filter chain before they are merged into a single file list.
        /// </summary>
        /// <param name="fileEnumerators">List of file enumerator and filter chain pairs. The filter chain may be null.</param>
        public CompoundFileEnumerator( IEnumerable<KeyValuePair<IFileEnumerator, IFilterChain>> fileEnumerators )
        {
            if( fileEnumerators != null )
                FileEnumerators = new List< KeyValuePair< IFileEnumerator, IFilterChain > >( fileEnumerators );
            else
                FileEnumerators = new List< KeyValuePair< IFileEnumerator, IFilterChain > >();
        }
        
        /// <summary>
        /// List of file enumerators forming the compound file enumerator.
        /// </summary>
        public IList< KeyValuePair<IFileEnumerator, IFilterChain> > FileEnumerators { get; private set; }

        /// <summary>
        /// Enumerates files.
        /// 
        /// This method constructs a merged file list from the source file enumerators and the associated filter chains,
        /// such that each file only occurs once, i.e. no duplicate file entries are returned.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<string> EnumerateFiles()
        {
            HashSet<string> alreadyEnumerated = new HashSet<string>();

            foreach( var fileEnumerator in FileEnumerators ) 
            {
                IEnumerable<string> currentOutput = fileEnumerator.Key;
                if( fileEnumerator.Value != null )
                    currentOutput = fileEnumerator.Value.Filter( currentOutput );

                IEnumerator<string> enumerator = null;
                enumerator = currentOutput.GetEnumerator();
                for( ; ; )
                {
                    try
                    {
                        if( !enumerator.MoveNext() )
                            break;
                    }
                    catch
                    {
                        continue;
                    }

                    string file = enumerator.Current;
                    if( !alreadyEnumerated.Contains( file ) )
                    {
                        alreadyEnumerated.Add( file );
                        yield return file;
                    }
                }
            }
        }

        /// <summary>
        /// Returns a file enumerator.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<string> GetEnumerator()
        {
            return EnumerateFiles().GetEnumerator();
        }

        /// <summary>
        /// Returns a file enumerator.
        /// </summary>
        /// <returns></returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return EnumerateFiles().GetEnumerator();
        }
    }

    /// <summary>
    /// CompoundFileEnumeratorBuilder class.
    /// 
    /// The CompoundFileEnumeratorBuilder class is a helper class, which facilitates the construction
    /// of a compound file enumerator by using method chaining.
    /// 
    /// </summary>
    /// <example>
    /// var compoundFileEnumerator = CompoundFileEnumeratorBuilder
    /// .Begin()
    ///     .DirectoryEnumerator( @"C:\Sources\CSharp", true, "*.cs", "*.xaml" )
    ///     .DirectoryEnumerator( @"C:\Sources\C++", true, "*.cpp", "*.h", "*.c", "*.hpp" )
    /// .End();
    /// </example>
    public class CompoundFileEnumeratorBuilder
    {
        private CompoundFileEnumerator mCompoundFileEnumerator;
        private IFileEnumerator mCurrentEnumerator;
        private IFilterChain mCurrentFilterChain;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="compoundFileEnumerator">Compound file enumerator, which should be configured through the builder.</param>
        private CompoundFileEnumeratorBuilder( CompoundFileEnumerator compoundFileEnumerator )
        {
            mCompoundFileEnumerator = compoundFileEnumerator;
        }

        /// <summary>
        /// Starts creating a compound file enumerator.
        /// </summary>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public static CompoundFileEnumeratorBuilder Begin()
        {
            return new CompoundFileEnumeratorBuilder( new CompoundFileEnumerator() );    
        }

        /// <summary>
        /// Adds a file enumerator of a given type to the compound enumerator.
        /// </summary>
        /// <typeparam name="ENUMERATOR_TYPE">Type of the file enumerator to be added to the compound enumerator.</typeparam>
        /// <param name="constructorArguments">Constructor arguments to be passed to the file enumerator constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileEnumerator<ENUMERATOR_TYPE>( params object[] constructorArguments ) where ENUMERATOR_TYPE : IFileEnumerator
        {
            NextEnumerator();
            mCurrentEnumerator = Activator.CreateInstance( typeof( ENUMERATOR_TYPE ), constructorArguments ) as IFileEnumerator;
            return this;
        }

        /// <summary>
        /// Adds a file enumerator of a given type to the compound enumerator.
        /// </summary>
        /// <param name="enumeratorType">Type of the file enumerator to be added to the compound enumerator.</param>
        /// <param name="constructorArguments">Constructor arguments to be passed to the file enumerator constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileEnumerator( Type enumeratorType, params object[] constructorArguments )
        {
            if( enumeratorType == null || !typeof( IFileEnumerator ).IsAssignableFrom( enumeratorType ) )
                return this;

            NextEnumerator();
            mCurrentEnumerator = Activator.CreateInstance( enumeratorType, constructorArguments ) as IFileEnumerator;
            return this;
        }

        /// <summary>
        /// Adds a file catalogue enumerator of a given type to the compound enumerator.
        /// </summary>
        /// <typeparam name="FILECATALGOUE_ENUMERATOR_TYPE">Type of the file catalogue enumerator to be added to the compound file enumerator.</typeparam>
        /// <param name="fileCatalgouePath">Path of the file catalogue, which should be enumerated by the file catalogue enumerator.</param>
        /// <param name="recursive">Indicates, whether the file catalogue enumerator should enumerate files recursively.</param>
        /// <param name="constructorArguments">Constructor arguments to be passed to the file catalogue enumerator constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileCatalogueEnumerator<FILECATALGOUE_ENUMERATOR_TYPE>( string fileCatalgouePath, bool recursive, params object[] constructorArguments ) where FILECATALGOUE_ENUMERATOR_TYPE : IFileCatalogueEnumerator
        {
            NextEnumerator();

            var fileCatalogueEnumerator = Activator.CreateInstance( typeof( FILECATALGOUE_ENUMERATOR_TYPE ), constructorArguments ) as IFileCatalogueEnumerator;
            fileCatalogueEnumerator.FileCataloguePath = fileCatalgouePath;
            fileCatalogueEnumerator.Recursive = recursive;
            mCurrentEnumerator = fileCatalogueEnumerator;

            return this;
        }

        /// <summary>
        /// Adds a file catalogue enumerator of a given type to the compound enumerator.
        /// </summary>
        /// <param name="fileCatalogueEnumeratorType">Type of the file catalogue enumerator to be added to the compound file enumerator.</param>
        /// <param name="fileCatalgouePath">Path of the file catalogue, which should be enumerated by the file catalogue enumerator.</param>
        /// <param name="recursive">Indicates, whether the file catalogue enumerator should enumerate files recursively.</param>
        /// <param name="constructorArguments">Constructor arguments to be passed to the file catalogue enumerator constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileCatalogueEnumerator( Type fileCatalogueEnumeratorType, string fileCatalgouePath, bool recursive, params object[] constructorArguments )
        {
            if( fileCatalogueEnumeratorType == null || !typeof( IFileCatalogueEnumerator ).IsAssignableFrom( fileCatalogueEnumeratorType ) )
                return this;

            NextEnumerator();

            var fileCatalogueEnumerator = Activator.CreateInstance( fileCatalogueEnumeratorType, constructorArguments ) as IFileCatalogueEnumerator;
            fileCatalogueEnumerator.FileCataloguePath = fileCatalgouePath;
            fileCatalogueEnumerator.Recursive = recursive;
            mCurrentEnumerator = fileCatalogueEnumerator;

            return this;
        }

        /// <summary>
        /// Adds a file catalogue enumerator to the compound file enumerator.
        /// </summary>
        /// <param name="fileCatalogueEnumerator">File catalogue enumerator, which should be added.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileCatalogueEnumerator( IFileCatalogueEnumerator fileCatalogueEnumerator )
        {
            if( fileCatalogueEnumerator == null )
                return this;
            
            NextEnumerator();

            mCurrentEnumerator = fileCatalogueEnumerator;

            return this;
        }

        /// <summary>
        /// Adds a file catalogue enumerator to the compound file enumerator.
        /// </summary>
        /// <param name="fileCataloguePath">File catalogue path for which a file catalogue enumerator should be added.</param>
        /// <returns></returns>
        public CompoundFileEnumeratorBuilder FileCatalogueEnumerator( string fileCataloguePath )
        {
            return FileCatalogueEnumerator( FileCatalogueEnumerators.GetFileCatalogueEnumeratorForPath( fileCataloguePath ) );
        }

        /// <summary>
        /// Adds a fixed file enumerator to the compound file enumerator. This enumerator just enumerates the provided list of files.
        /// </summary>
        /// <param name="files">List of file which should be enumerated by the fixed file enumerator.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileEnumerator( params string[] files )
        {
            NextEnumerator();

            mCurrentEnumerator = new FixedFileEnumerator( files );

            return this;
        }

        /// <summary>
        /// Adds a file enumerator to the compound file enumerator.
        /// </summary>
        /// <param name="fileEnumerator">File enumerator to be added.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder FileEnumerator( IFileEnumerator fileEnumerator )
        {
            if( fileEnumerator == null )
                return this;

            NextEnumerator();

            mCurrentEnumerator = fileEnumerator;

            return this;
        }

        /// <summary>
        /// Adds a directory enumerator to the compound file enumerator. The directory enumerator simply enumerates the files contained in the given directory.
        /// </summary>
        /// <param name="directoryPath">Path of the directory, whose content should be enumerated.</param>
        /// <param name="recursive">Specifies, whether the directory should be enumerated recursively.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder DirectoryEnumerator( string directoryPath, bool recursive )
        {
            NextEnumerator();

            mCurrentEnumerator = new DirectoryFileEnumerator( directoryPath, recursive );

            return this;
        }

        /// <summary>
        /// Adds a directory enumerator to the compound file enumerator. The directory enumerator simply enumerates the files contained in the given directory.
        /// </summary>
        /// <param name="directoryPath">Path of the directory, whose content should be enumerated.</param>
        /// <param name="recursive">Specifies, whether the directory should be enumerated recursively.</param>
        /// <param name="wildcardPatterns">List of wild card patterns, for the files, which should be listed by the directory enumerator.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder DirectoryEnumerator( string directoryPath, bool recursive, params string[] wildcardPatterns )
        {
            NextEnumerator();

            mCurrentEnumerator = new DirectoryFileEnumerator( directoryPath, recursive );            
            WildcardFilter( wildcardPatterns );

            return this;
        }

        /// <summary>
        /// Adds a directory enumerator to the compound file enumerator. The directory enumerator simply enumerates the files contained in the given directory.
        /// </summary>
        /// <param name="directoryPath">Path of the directory, whose content should be enumerated.</param>
        /// <param name="recursive">Specifies, whether the directory should be enumerated recursively.</param>
        /// <param name="includeWildcardPatterns">List of wild card patterns, for the files, which should be listed by the directory enumerator.</param>
        /// <param name="excludeWildcardPatterns">List of wild card patterns, for files, which should be excluded by the directory enumerator.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder DirectoryEnumerator( string directoryPath, bool recursive, string[] includeWildcardPatterns, string[] excludeWildcardPatterns )
        {
            NextEnumerator();

            mCurrentEnumerator = new DirectoryFileEnumerator( directoryPath, recursive );
            if( includeWildcardPatterns != null && includeWildcardPatterns.Length > 0 )
                WildcardFilter( FileFilterMode.Inclusive, includeWildcardPatterns );
            if( excludeWildcardPatterns != null && excludeWildcardPatterns.Length > 0 )
                WildcardFilter( FileFilterMode.Exclusive, excludeWildcardPatterns );

            return this;
        }

        /// <summary>
        /// Appends a file filter to the previously added file enumerator.
        /// </summary>
        /// <typeparam name="FILTER_TYPE">Type of the filter to be appended.</typeparam>
        /// <param name="constructorArguments">Constructor arguments to be passed to the filter constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder Filter<FILTER_TYPE>( params object[] constructorArguments ) where FILTER_TYPE : IFileFilter
        {
            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            var filter = Activator.CreateInstance( typeof( FILTER_TYPE ), constructorArguments ) as IFileFilter;
            mCurrentFilterChain.Filters.Add( filter );

            return this;
        }

        /// <summary>
        /// Appends a file filter to the previously added file enumerator.
        /// </summary>
        /// <param name="filterType">Type of the filter to be appended.</param>
        /// <param name="constructorArguments">Constructor arguments to be passed to the filter constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder Filter( Type filterType, params object[] constructorArguments )
        {
            if( filterType == null || !typeof( IFileFilter ).IsAssignableFrom( filterType ) )
                return this;

            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            var filter = Activator.CreateInstance( filterType, constructorArguments ) as IFileFilter;
            mCurrentFilterChain.Filters.Add( filter );

            return this;
        }

        /// <summary>
        /// Appends a file filter to the previously added file enumerator.
        /// </summary>
        /// <typeparam name="FILTER_TYPE">Type of the filter to be appended.</typeparam>
        /// <param name="mode">Mode, in which the file filter should operate.</param>
        /// <param name="constructorArguments">Constructor arguments to be passed to the filter constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder Filter<FILTER_TYPE>( FileFilterMode mode, params object[] constructorArguments ) where FILTER_TYPE : IInvertibleFileFilter
        {
            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            var filter = Activator.CreateInstance( typeof( FILTER_TYPE ), constructorArguments ) as IInvertibleFileFilter;
            filter.Mode = mode;
            mCurrentFilterChain.Filters.Add( filter );

            return this;
        }

        /// <summary>
        /// Appends a file filter to the previously added file enumerator.
        /// </summary>
        /// <param name="filterType">Type of the filter to be appended.</param>
        /// <param name="mode">Mode, in which the file filter should operate.</param>
        /// <param name="constructorArguments">Constructor arguments to be passed to the filter constructor.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder Filter( Type filterType, FileFilterMode mode, params object[] constructorArguments )
        {
            if( filterType == null || !typeof( IInvertibleFileFilter ).IsAssignableFrom( filterType ) )
                return this;

            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            var filter = Activator.CreateInstance( filterType, constructorArguments ) as IInvertibleFileFilter;
            filter.Mode = mode;
            mCurrentFilterChain.Filters.Add( filter );

            return this;
        }

        /// <summary>
        /// Appends a wild card filter to the last file enumerator.
        /// </summary>
        /// <param name="patterns">Wild card patterns of files, which should pass thru.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder WildcardFilter( params string[] patterns )
        {
            return WildcardFilter( FileFilterMode.Inclusive, patterns );
        }

        /// <summary>
        /// Appends a wild card file filter to the last file enumerator added to the compound file enumerator.
        /// </summary>
        /// <param name="mode">Mode in which the wildcard filter should operate.</param>
        /// <param name="patterns">Wild card patterns of files, which should either pass thru or be filtered out depending on the specified filter mode.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder WildcardFilter( FileFilterMode mode, params string[] patterns )
        {
            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            mCurrentFilterChain.Filters.Add( new Filters.WildCardFileFilter( mode, patterns ) );

            return this;
        }

        /// <summary>
        /// Appends a regex file filter to the last file enumerator added to the compound file enumerator.
        /// </summary>
        /// <param name="patterns">Regex patterns of files, which should pass thru the filter.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder RegexFilter( params string[] patterns )
        {
            return RegexFilter( FileFilterMode.Inclusive, patterns );
        }

        /// <summary>
        /// Appends a regex file filter to the last file enumerator added to the compound file enumerator.
        /// </summary>
        /// <param name="mode">Mode, in which the file filter should operate.</param>
        /// <param name="patterns">Regex patterns of files, which should either pass thru or be filtered out depending on the specified filter mode.</param>
        /// <returns>CompoundFileEnumeratorBuilder creating the current compound file enumerator.</returns>
        public CompoundFileEnumeratorBuilder RegexFilter( FileFilterMode mode, params string[] patterns )
        {
            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            mCurrentFilterChain.Filters.Add( new Filters.RegExFileFilter( mode, patterns ) );

            return this;
        }

        /// <summary>
        /// Starts a new file enumerator entry.
        /// </summary>
        private void NextEnumerator()
        {
            if( mCurrentEnumerator != null )
            {
                mCompoundFileEnumerator.FileEnumerators.Add( new KeyValuePair<IFileEnumerator, IFilterChain>( mCurrentEnumerator, mCurrentFilterChain ) );
                mCurrentEnumerator = null;
                mCurrentFilterChain = null;
            }
        }

        /// <summary>
        /// Finishes construction of a compound file enumerator.
        /// </summary>
        /// <returns>Constructed and configured CompoundFileEnumerator instance.</returns>
        public CompoundFileEnumerator End()
        {
            NextEnumerator();
            return mCompoundFileEnumerator;
        }

        internal const string XML_ELEMENT_FILE_SOURCES = "FileSources";
        internal const string XML_ELEMENT_CONFIGURATION = "Configuration";
        internal const string XML_ELEMENT_SOURCE = "Source";
        internal const string XML_ELEMENT_CATALOGUE = "Catalogue";
        internal const string XML_ELEMENT_FILTER = "Filter";
        internal const string XML_ELEMENT_DIRECTORY = "Directory";
        internal const string XML_ELEMENT_FILE = "File";
        internal const string XML_ATTRIBUTE_TYPE = "Type";
        internal const string XML_ATTRIBUTE_PATH = "Path";
        internal const string XML_ATTRIBUTE_RECURSIVE = "Recursive";
        internal const string XML_ATTRIBUTE_PATTERNS = "Patterns";
        internal const string XML_ATTRIBUTE_MODE = "Mode";
        internal const string XML_ATTRIBUTE_INCLUDE = "Include";
        internal const string XML_ATTRIBUTE_EXCLUDE = "Exclude";

        /// <summary>
        /// Creates a CompoundFileEnumerator from an XML configuration file.
        /// </summary>
        /// <param name="fileName">Name of the XML configuration file containing the configuration of the compound file enumerator.</param>
        /// <returns>Instance of CompoundFileEnumerator configured as specified in the XML file.</returns>
        public static CompoundFileEnumerator BuildFromXmlFile( string fileName )
        {
            using( var stream = new System.IO.FileStream( fileName, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.Read ) )
            {
                var fileEnumerator = BuildFromXml( stream );
                stream.Close();
                return fileEnumerator;
            }
        }

        /// <summary>
        /// Creates a CompoundFileEnumerator from an XML configuration.
        /// </summary>
        /// <param name="xmlStream">Stream containing XML data, from which the compound file enumerator should be configured.</param>
        /// <returns>Instance of CompoundFileEnumerator configured as specified in the XML data.</returns>
        public static CompoundFileEnumerator BuildFromXml( System.IO.Stream xmlStream )
        {
            return BuildFromXml( XDocument.Load( xmlStream ).Root );
        }

        /// <summary>
        /// Creates a CompoundFileEnumerator from an XML configuration.
        /// </summary>
        /// <param name="xmlReader">Text reader providing XML data, from which the compound file enumerator should be configured.</param>
        /// <returns>Instance of CompoundFileEnumerator configured as specified in the XML data.</returns>
        public static CompoundFileEnumerator BuildFromXml( System.IO.TextReader xmlReader )
        {
            return BuildFromXml( XDocument.Load( xmlReader ).Root );
        }

        /// <summary>
        /// Creates a CompoundFileEnumerator from an XML configuration.
        /// </summary>
        /// <param name="xml">String containing XML data, from which the compound file enumerator should be configured.</param>
        /// <returns>Instance of CompoundFileEnumerator configured as specified in the XML data.</returns>
        public static CompoundFileEnumerator BuildFromXml( string xml )
        {
            return BuildFromXml( XDocument.Parse( xml ).Root );            
        }

        /// <summary>
        /// Creates a CompoundFileEnumerator from an XML configuration.
        /// </summary>
        /// <param name="root">XML root element of the compound file enumerator configuration.</param>
        /// <returns>Instance of CompoundFileEnumerator configured as specified in the XML data.</returns>
        public static CompoundFileEnumerator BuildFromXml( XElement root )
        {
            // Check root element of configuration.
            if( root.Name.LocalName == XML_ELEMENT_FILE_SOURCES )
            {
                var builder = CompoundFileEnumeratorBuilder.Begin();

                // Iterate over all Directory elements and create directory file enumerators.
                foreach( var directory in root.Elements().Where( element => element.Name.LocalName == XML_ELEMENT_DIRECTORY ) )
                {
                    var pathAttribute = directory.Attribute( XML_ATTRIBUTE_PATH );
                    var includeAttribute = directory.Attribute( XML_ATTRIBUTE_INCLUDE );
                    var excludeAttribute = directory.Attribute( XML_ATTRIBUTE_EXCLUDE );
                    var patternsAttribute = directory.Attribute( XML_ATTRIBUTE_PATTERNS );
                    var recursiveAttribute = directory.Attribute( XML_ATTRIBUTE_RECURSIVE );

                    if( pathAttribute != null && !string.IsNullOrEmpty( pathAttribute.Value ) )
                    {
                        string path = pathAttribute.Value.Trim();
                        bool recursive;
                        if( recursiveAttribute == null || bool.TryParse( recursiveAttribute.Value, out recursive ) )
                            recursive = false;
                        HashSet<string> includePatterns = new HashSet<string>();
                        HashSet<string> excludePatterns = new HashSet<string>();
                        FillListFromAttribute( includeAttribute, includePatterns );
                        FillListFromAttribute( patternsAttribute, includePatterns );
                        FillListFromAttribute( excludeAttribute, excludePatterns );

                        builder = builder.DirectoryEnumerator( path, recursive, includePatterns.ToArray(), excludePatterns.ToArray() );
                        builder.AddFiltersFromXml( directory );
                    }
                }

                // Iterate over all File elements and create direct file enumerators.
                foreach( var file in root.Elements().Where( element => element.Name.LocalName == XML_ELEMENT_FILE ) )
                {
                    var pathAttribute = file.Attribute( XML_ATTRIBUTE_PATH );

                    if( pathAttribute != null && !string.IsNullOrEmpty( pathAttribute.Value ) )
                    {
                        string path = pathAttribute.Value.Trim();
                        builder = builder.FileEnumerator( path );
                        builder.AddFiltersFromXml( file );
                    }
                }

                // Iterate over all Catalogue elements and create catalogue enumerators.
                foreach( var catalogue in root.Elements().Where( element => element.Name.LocalName == XML_ELEMENT_CATALOGUE ) )
                {
                    var pathAttribute = catalogue.Attribute( XML_ATTRIBUTE_PATH );
                    var typeAttribute = catalogue.Attribute( XML_ATTRIBUTE_TYPE );
                    var recursiveAttribute = catalogue.Attribute( XML_ATTRIBUTE_RECURSIVE );

                    // Select by catalogue path
                    if( pathAttribute != null && !string.IsNullOrEmpty( pathAttribute.Value ) && typeAttribute == null )
                    {
                        string path = pathAttribute.Value.Trim();
                        var fileCatalogueEnumeratorType = FileCatalogueEnumerators.GetFileCatalogueEnumeratorTypeForPath( path );
                        var fileCatalogueEnumerator = fileCatalogueEnumeratorType.CreateAndConfigure( catalogue.Element( XML_ELEMENT_CONFIGURATION ) ) as IFileCatalogueEnumerator;
                        if( fileCatalogueEnumerator != null ) 
                        {
                            if( recursiveAttribute != null )
                            {
                                bool recursive = false;
                                if( bool.TryParse( recursiveAttribute.Value, out recursive ) )
                                {
                                    fileCatalogueEnumerator.Recursive = recursive;
                                }
                            }
                            fileCatalogueEnumerator.FileCataloguePath = path;
                            builder = builder.FileCatalogueEnumerator( fileCatalogueEnumerator );
                            builder.AddFiltersFromXml( catalogue );                            
                        }
                    }
                    else
                    // Create from type and configure
                    if( typeAttribute != null && !string.IsNullOrEmpty( typeAttribute.Value ) )
                    {
                        var fileCatalogueEnumerator = FileCatalogueEnumerators.CreateFileCatalogueEnumerator( catalogue );
                        if( fileCatalogueEnumerator != null )
                        { 
                            if( recursiveAttribute != null )
                            {
                                bool recursive = false;
                                if( bool.TryParse( recursiveAttribute.Value, out recursive ) )
                                {
                                    fileCatalogueEnumerator.Recursive = recursive;
                                }
                            }
                            if( pathAttribute != null && !string.IsNullOrEmpty( pathAttribute.Value ) )
                                fileCatalogueEnumerator.FileCataloguePath = pathAttribute.Value.Trim();

                            builder = builder.FileCatalogueEnumerator( fileCatalogueEnumerator );
                            builder.AddFiltersFromXml( catalogue );
                        }
                    }
                }

                // Iterate over all Source elements and create catalogue enumerators.
                foreach( var source in root.Elements().Where( element => element.Name.LocalName == XML_ELEMENT_SOURCE ) )
                {
                    // Create from type and configure
                    var fileEnumerator = FileEnumerators.CreateFileEnumerator( source );
                    if( fileEnumerator != null )
                    {
                        builder = builder.FileEnumerator( fileEnumerator );
                        builder.AddFiltersFromXml( source );
                    }
                }

                return builder.End();
            }
            return null;
        }

        /// <summary>
        /// Adds filters below the specified xml element.
        /// </summary>
        /// <param name="root">Filter root element.</param>
        private void AddFiltersFromXml( XElement root )
        {
            if( mCurrentFilterChain == null )
                mCurrentFilterChain = new Filters.FilterChain();

            AddFiltersFromXml( mCurrentFilterChain, root );
        }

        /// <summary>
        /// Adds filters below the specified xml element.
        /// </summary>
        /// <param name="root">Filter root element.</param>
        private void AddFiltersFromXml( IFilterChain chain, XElement root )
        {
            if( root == null )
                return;
            foreach( var filterElement in root.Elements().Where( element => element.Name.LocalName == XML_ELEMENT_FILTER ) )
            {
                var fileFilter = FileFilters.CreateFileFilter( filterElement );
                if( fileFilter != null )
                {
                    // Configure filter mode
                    IInvertibleFileFilter invertibleFileFilter = fileFilter as IInvertibleFileFilter;
                    if( invertibleFileFilter != null )
                    {
                        var modeAttribute = filterElement.Attribute( XML_ATTRIBUTE_MODE );
                        if( modeAttribute != null )
                        {
                            FileFilterMode mode;
                            if( Enum.TryParse<FileFilterMode>( modeAttribute.Value, true, out mode ) )
                                invertibleFileFilter.Mode = mode;
                        }
                    }
                    
                    // Add sub filters, if the filter is a filter chain.
                    IFilterChain filterChain = fileFilter as IFilterChain;
                    if( filterChain != null )
                        AddFiltersFromXml( filterChain, filterElement );

                    chain.Filters.Add( fileFilter );
                }
            }
        }

        /// <summary>
        /// Fills a string list from the specified XML attribute.
        /// </summary>
        /// <param name="listAttribute">XML attribute containing a list of string elements.</param>
        /// <param name="list">List, which should be filled, with the elements contained in the XML attribute.</param>
        /// <param name="separator">Separator character, which delimits the elements.</param>
        private static void FillListFromAttribute( XAttribute listAttribute, ICollection<string> list, Char separator = '|' )
        {
            if( listAttribute == null )
                return;
            foreach( string trimmedEntry in listAttribute.Value.Split( separator ).Select( entry => entry.Trim() ) )
            {
                if( !string.IsNullOrEmpty( trimmedEntry ) )
                    list.Add( trimmedEntry );
            }
        }
    }
}
